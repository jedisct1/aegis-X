%
% Parameters
%

\nocite{*}

\ifdefined\fullversion
\else
\def\fullversion{1}    % 0 = conference version; 1 = full version
\fi

\ifdefined\cameraversion
\else
\def\cameraversion{0}    % 0 = long version; 1 = proceedings version
\fi

\def\showoverflow{1}   % 1 = show overflows
\def\allow{1}      % 0 = remove todo command
\def\anonymous{0}      % 1 = anonymous

%
% Document class 
%

\documentclass[envcountsame,runningheads,notitlepage]{llncs}
\ifnum\fullversion=1
\usepackage[a4paper, margin=1.1in]{geometry}
\setlength{\marginparwidth}{2.5cm}
\fi

%
% Custom additions
%

\usepackage{algorithm}
\usepackage{xcolor}
\usepackage{listings}
\usepackage{xparse}

%
% Custom header
%

\input{tex_files/ZZ_header}

\title{Adding more parallelism to the AEGIS authenticated encryption algorithms}
\titlerunning{AEGIS-128X and AEGIS-256X}
\date{Apr, 2023}

\ifnum\anonymous=0
\author{
  Frank Denis\inst{}
}

\institute{Fastly Inc.\\
  \href{mailto:fde@00f.net}{fde@00f.net}
}

\else
\author{} 
\institute{}
\fi

\begin{document}
\maketitle

\markboth{}{}

\begin{abstract}
  While the round function of the AEGIS authenticated encryption algorithms is highly parallelisable, their mode of operation is not.

  We introduce two new modes to overcome that limitation: AEGIS-128X and AEGIS-256X, that require minimal changes to existing implementations and retain the security properties of AEGIS-128L and AEGIS-256.
\end{abstract}

\section{Introduction}
\label{sec:introduction}

AEGIS \cite{SAC:WuPre13} is a family of three authenticated encryption algorithms, originally designed to leverage the AES-NI instructions set introduced by Intel in 2010 \cite{Akdemir2010BreakthroughAP}.
These instructions perform several compute intensive parts of the AES algorithm, significantly improving the performance of software AES implementations while minimizing the risks of side channel attacks.

However, concurrent AES round instructions are required to fully utilize the AES pipelines. The AEGIS round function was specifically designed with this in mind, and allows up to 8 AES blocks to be updated concurrently. Its design made it the fastest candidate of the CAESAR competition on Intel CPUs with hardware AES acceleration \cite{EPRINT:ARAR16}.

Nonetheless, the mode of operation is similar to a duplex: after its initialization, the state is continuously updated by applying the round function to itself.
That effectively limits the parallelism of the construction to the parallelism of the round function.

In \cite{FSE:BogLauTis15}, Bogdanov, Lauridsen, and Tischhauser made a similar observation regarding multiple candidates of the CAESAR competition. They proposed a novel "comb scheduler" able to process multiple messages simultaneously.

The modes presented here also encrypt multiple messages simultaneously using the same cipher, but assume that they are fragments of the same message, and share the same key, initialization vector and length.

Given a parallelism degree $\nu$, an input message is split into $\nu$ evenly distributed parts, that can be encrypted concurrently. The resulting ciphertexts are then combined, as well as their authentication tags.

The underlying encryption algorithms remain the existing AEGIS algorithms, with a minor addition to their initialization functions.

\section{Operations, Variables and Functions}
\label{sec:notation}

The operations, variables and functions used in this document are defined below.

\subsection{Operations}

\begin{tabular}{l c p{.5\textwidth}}
$\lvert x \rvert$              & : & Size of $x$ in bits                                    \\
  $x \oplus y$                   & : & Bit-wise exclusive OR                                  \\
  $\F_{128L}(S, m_0, m_1)$       & : & AEGIS-128L state update function                       \\
  $\F_{256}(S, m)$               & : & AEGIS-256 state update function                        \\
  $x \| y$                       & : & Concatenation of $x$ and $y$                           \\
  $Pad(x,\ell)$                  & : & Add trailing $0$ bits to pad $x$ to $\ell$ bits        \\
  $Enc_{128L}(CTX, K, IV, A, M)$ & : & AEGIS-128L encryption function with context separation \\
  $Enc_{256}(CTX, K, IV, A, M)$  & : & AEGIS-256 encryption function with context separation  \\
$Enc_{128X}[\nu](K, IV, A, M)$  & : & AEGIS-128X$[\nu]$ parallel encryption function         \\
$Enc_{256X}[\nu](K, IV, A, M)$  & : & AEGIS-256X$[\nu]$ parallel encryption function         \\
  $Trunc(x, \ell)$               & : & Truncate $x$ to the first $\ell$ bits                  \\
\end{tabular}

\subsection{Variables and constants}

\begin{tabular}{l c p{.5\textwidth}}
  $AD$                  & : & Associated data or $\{\}$ if unspecified                        \\
  $AD_i$                & : & 128-bit associated data block                                   \\
  $\hat{AD}$            & : & $AD$, padded to $r \cdot \nu$ bits                              \\
  $\hat{AD}_i$          & : & 128-bit associated data block                                   \\
  $\overline{AD}_i$     & : & $\hat{AD}$ fragment ($\frac{\lvert \hat{AD} \rvert}{\nu}$ bits) \\
  $\overline{AD}_{i,j}$ & : & 128-bit $\hat{AD}$ fragment block                               \\
  $C$                   & : & Ciphertext                                                      \\
  $\hat{C}$             & : & $C$, padded to $r \cdot \nu$ bits                               \\
  $\hat{C}_i$           & : & A 128-bit ciphertext block                                      \\
  $\overline{C}_i$      & : & $C$ fragment ($\frac{\lvert \hat{C} \rvert}{\nu}$ bits)         \\
  $\overline{C}_{i,j}$  & : & 128-bit $C$ fragment block                                      \\
  $const_0$             & : & First half of the AEGIS constant (128 bits)                     \\
  $const_1$             & : & Second half of the AEGIS constant (128 bits)                    \\
  $CTX$                 & : & Context separator                                               \\
  $K_{128}$             & : & 128-bit encryption key (AEGIS-128, -128L)                       \\
  $K_{256}$             & : & 256-bit encryption key (AEGIS-256)                              \\
  $K_{256,0}$           & : & First half of a 256-bit key                                     \\
  $K_{256,1}$           & : & Second half of a 256-bit key                                    \\
  $P$                   & : & Plaintext                                                       \\
  $\hat{P}$             & : & $P$, padded to $r \cdot \nu$ bits                               \\
  $\hat{P}_i$           & : & 128-bit plaintext block                                         \\
  $\overline{P}$        & : & $P$ fragment ($\frac{\lvert \hat{P} \rvert}{\nu}$ bits)         \\
  $\overline{P}_i$      & : & 128-bit $P$ fragment block                                      \\
  $IV_{128}$            & : & 128-bit initialization vector (AEGIS-128, -128L)                \\
  $IV_{256}$            & : & 256-bit initialization vector  (AEGIS-256)                      \\
  $IV_{256,0}$          & : & First half of a 256-bit initialization vector                   \\
  $IV_{256,1}$          & : & Second half of a 256-bit initialization vector                  \\
  $\nu$                 & : & Parallelism degree ($\geq 1$)                                   \\
  $r$                   & : & Absorption rate (128 or 256 bits)                               \\
  $S$                   & : & AEGIS state                                                     \\
  $S_i$                 & : & A 128-bit AEGIS state block                                     \\
  $T$                   & : & Authentication tag for $C$                                      \\
  $\overline{T}_i$      & : & Authentication tag for $\overline{C}_i$                         \\
\end{tabular}

\section{Context separation}
\label{sec:context separation}

From an application perspective, new AEGIS variants should ideally share the same interface as existing variants. Namely, they should accept a single message, optional associated data, a 128 or 256 bit key, and a 128 or 256 bit initialization vector.

However, AEGIS is meant to be used in a nonce-respecting scenario \cite{ACNS:VauViz18}. Clearly, reusing the same key and $IV$ to encrypt different parts of a message would violate that contract.

In order to avoid universal forgery and decryption attacks, we augment the AEGIS initialization functions with a context, meant to provide domain separation. That is, for two different values $CTX_0 \neq CTX_1$, $Enc_{\cdot}[\cdot](CTX_0, \cdot)$ and $Enc_{\cdot}[\cdot](CTX_1, \cdot)$ act as two different functions of $\{ K, IV, A, M \}$.

\subsection{Augmenting AEGIS-128L for context separation}
\label{sec:augmenting AEGIS-128L for context separation}

AEGIS-128L defines the initial state $S$ as a vector of eight AES blocks $\{S_0, S_1, \ldots S_7\}$ set to:

\begin{center}
  \begin{tabular}{|c|c|}
    \hline
    Block & Initial value             \\
    \hline
    $S_0$ & $K_{128} \oplus IV_{128}$ \\
    \hline
    $S_1$ & $const_1$                 \\
    \hline
    $S_2$ & $const_0$                 \\
    \hline
    $S_3$ & $const_1$                 \\
    \hline
    $S_4$ & $K_{128} \oplus IV_{128}$ \\
    \hline
    $S_5$ & $K_{128} \oplus const_0$  \\
    \hline
    $S_6$ & $K_{128} \oplus const_1$  \\
    \hline
    $S_7$ & $K_{128} \oplus const_0$  \\
    \hline
  \end{tabular}
\end{center}

From this state, the original AEGIS-128L initialization function performs 10 updates as described in algorithm \ref{contextless aegis-128l initialization}.

\begin{algorithm}
  \caption{Contextless AEGIS-128L initialization}
  \label{contextless aegis-128l initialization}
  \begin{algorithmic}
    \Function{Initialize}{K, IV}
    \State $S \gets \{ K_{128} \oplus IV_{128}, const_1, const_0, const_1, K_{128} \oplus IV_{128}, K_{128} \oplus const_0, K_{128} \oplus const_1, K_{128} \oplus const_0 \}$
    \State $i \gets 0$
    \While{$i < 10$}
    \State $S \gets \F_{128L}(S, IV_{128}, K_{128})$
    \State $i \gets i+1$
    \EndWhile
    \EndFunction
  \end{algorithmic}
\end{algorithm}

\paragraph{}

We augment this function to accept a context parameter $CTX$.
Before each update, the context is added to the 3rd and 7th words of the state, as described in algorithm \ref{aegis-128l initialization with context}

\paragraph{}

Note that when $CTX = 0$, the resulting state is exactly the same as AEGIS-128L, as originally specified, without a context.

\begin{algorithm}
  \caption{AEGIS-128L initialization with context}
  \label{aegis-128l initialization with context}
  \begin{algorithmic}
    \Function{Initialize}{CTX, K, IV}
    \State $S \gets \{ K_{128} \oplus IV_{128}, const_1, const_0, const_1, K_{128} \oplus IV_{128}, K_{128} \oplus const_0, K_{128} \oplus const_1, K_{128} \oplus const_0 \}$
    \State $i \gets 0$
    \While{$i < 10$}
    \State $S_3 \gets S_3 \oplus Pad(CTX, 128)$
    \State $S_7 \gets S_7 \oplus Pad(CTX, 128)$
    \State $S \gets \F_{128L}(S, IV_{128}, K_{128})$
    \State $i \gets i+1$
    \EndWhile
    \EndFunction
  \end{algorithmic}
\end{algorithm}

\subsection{Augmenting AEGIS-256 for context separation}
\label{sec:augmenting AEGIS-256 for context separation}

AEGIS-256 accepts a 256-bit key $K_{256}$ made of two AES blocks $\{ K_{256,0}, K_{256,1} \}$, as well as 256-bit initialization vector $IV_{256}$ made of two AES blocks $\{ IV_{256,0}, IV_{256,1} \}$.

\paragraph{}

The initial state $S$ is a vector of six AES blocks $\{S_0, S_1, \ldots S_5\}$ set to:

\begin{center}
  \begin{tabular}{|c|c|}
    \hline
    Block & Initial value                 \\
    \hline
    $S_0$ & $K_{256,0} \oplus IV_{256,0}$ \\
    \hline
    $S_1$ & $K_{256,1} \oplus IV_{256,1}$ \\
    \hline
    $S_2$ & $const_0$                     \\
    \hline
    $S_3$ & $const_1$                     \\
    \hline
    $S_4$ & $K_{256,0} \oplus const_1$    \\
    \hline
    $S_5$ & $K_{256,1}1 \oplus const_0$   \\
    \hline
  \end{tabular}
\end{center}

From this state, the original AEGIS-256 initialization function performs 16 updates as described in algorithm \ref{contextless aegis-256 initialization}.

\begin{algorithm}
  \caption{Contextless AEGIS-256 initialization}
  \label{contextless aegis-256 initialization}
  \begin{algorithmic}
    \Function{Initialize}{K, IV}
    \State $S \gets \{ K_{256,0} \oplus IV_{256,0}, K_{256,1} \oplus IV_{256,1}, const_0, const_1, K_{256,0} \oplus const_1, K_{256,1} \oplus const_0 \}$
    \State $i \gets 0$
    \While{$i < 4$}
    \State $S \gets \F_{256}(S, K_{256,0})$
    \State $S \gets \F_{256}(S, K_{256,1})$
    \State $S \gets \F_{256}(S, IV_{256,0})$
    \State $S \gets \F_{256}(S, IV_{256,1})$
    \State $i \gets i+1$
    \EndWhile
    \EndFunction
  \end{algorithmic}
\end{algorithm}

We augment this function to accept a context parameter $CTX$.
Before each update, the context is added to the 3rd and 5th words of the state, as described in algorithm \ref{aegis-256 initialization with context}

Note that when $CTX = 0$, the resulting state is exactly the same as AEGIS-256, as originally specified, without a context.

\begin{algorithm}
  \caption{AEGIS-256 initialization with context}
  \label{aegis-256 initialization with context}
  \begin{algorithmic}
    \Function{Initialize}{CTX, K, IV}
    \State $S \gets \{ K_{256,0} \oplus IV_{256,0}, K_{256,1} \oplus IV_{256,1}, const_0, const_1, K_{256,0} \oplus const_1, K_{256,1} \oplus const_0 \}$
    \State $i \gets 0$
    \While{$i < 4$}
    \State $S_3 \gets S_3 \oplus Pad(CTX, 128)$
    \State $S_5 \gets S_5 \oplus Pad(CTX, 128)$
    \State $S \gets \F_{256}(S, K_{256,0})$
    \State $S_3 \gets S_3 \oplus Pad(CTX, 128)$
    \State $S_5 \gets S_5 \oplus Pad(CTX, 128)$
    \State $S \gets \F_{256}(S, K_{256,1})$
    \State $S_3 \gets S_3 \oplus Pad(CTX, 128)$
    \State $S_5 \gets S_5 \oplus Pad(CTX, 128)$
    \State $S \gets \F_{256}(S, IV_{256,0})$
    \State $S_3 \gets S_3 \oplus Pad(CTX, 128)$
    \State $S_5 \gets S_5 \oplus Pad(CTX, 128)$
    \State $S \gets \F_{256}(S, IV_{256,1})$
    \State $i \gets i+1$
    \EndWhile
    \EndFunction
  \end{algorithmic}
\end{algorithm}

\section{The AEGIS-128X and AEGIS-256X modes}
\label{sec:parallel processing}

AEGIS absorbs the associated data and message with a rate $r$ with $r=256$ for AEGIS-128L and $r=128$ for AEGIS-128 and AEGIS-256.

We define two new modes: AEGIS-128X$[\nu]$ and AEGIS-256X$[\nu]$, that absorb $r \cdot \nu$ bits per state update, spread over $\nu$ concurrent instances of the AEGIS-128L or AEGIS-256 encryption functions.

The associated data $AD$ and plaintext $P$ are split into interleaved blocks with a stride of $r \cdot \nu$ bits as they arrive. The last blocks are padded if necessary.

\paragraph{}

We first pad $AD$ and $P$ by adding trailing zero bits until they match the stride length:

\begin{math}
  \\
  \hat{AD} = Pad(AD, r \cdot \nu) \\
  \hat{P} = Pad(P, r \cdot \nu)
\end{math}

\paragraph{}

$\hat{AD}$ is split into 128-bit blocks $\{ \hat{AD}_0, \hat{AD}_1, \ldots \hat{AD}_{\frac{\lvert \hat{AD} \rvert}{128}-1} \}$.

These blocks are interleaved to produce $\nu$ independent $\frac{\lvert \hat{AD} \rvert}{\nu}$ bit messages $\{ \overline{AD}_0, \overline{AD}_1, \ldots \overline{AD}_{\nu-1} \}$.

\begin{math}
  \\
  \overline{AD}_0 = \hat{AD}_0 \| \hat{AD}_{\nu} \| \hat{AD}_{2\nu} \| \hat{AD}_{3\nu} \| \ldots \\
  \overline{AD}_1 = \hat{AD}_1 \| \hat{AD}_{\nu+1} \| \hat{AD}_{2\nu+1} \| \hat{AD}_{3\nu+1} \| \ldots \\
  \overline{AD}_2 = \hat{AD}_2 \| \hat{AD}_{\nu+2} \| \hat{AD}_{2\nu+2} \| \hat{AD}_{3\nu+2} \| \ldots \\
  \vdots \\
  \overline{AD}_{\nu-1} = \hat{AD}_{\nu-1} \| \hat{AD}_{\nu+(nu-1)} \| \hat{AD}_{2\nu+(\nu-1)} \| \hat{AD}_{3\nu+(\nu-1)} \| \ldots
\end{math}

\paragraph{}

Similarly, $\hat{P}$ is split into $\nu$ independent $\frac{\lvert \hat{P} \rvert}{\nu}$ bit messages $\{ \overline{P}_0, \overline{P}_1, \ldots \overline{P}_{\nu-1} \}$.

\subsection{AEGIS-128X}

AEGIS-128X$[\nu]$ first encrypts and authenticates the plaintext and associated data fragments independently, producing $\nu$ ciphertexts $\{\overline{C}_0, \overline{C}_1, \ldots \overline{C}_{\nu-1} \}$ and authentication tags $\{\overline{T}_0, \overline{T}_1, \ldots \overline{T}_{\nu-1} \}$.

\begin{math}
  \\
  \{\overline{C}_0, \overline{T}_0\} = Enc_{128L}(CTX \leftarrow 0, K, IV, \overline{A}_0, \overline{M}_0) \\
  \{\overline{C}_1, \overline{T}_1\} = Enc_{128L}(CTX \leftarrow 1, K, IV, \overline{A}_1, \overline{M}_1) \\
  \{\overline{C}_2, \overline{T}_2\} = Enc_{128L}(CTX \leftarrow 2, K, IV, \overline{A}_2, \overline{M}_2) \\
  \vdots \\
  \{\overline{C}_{\nu-1}, \overline{T}_{\nu-1}\} = Enc_{128L}(CTX \leftarrow {\nu-1}, K, IV, \overline{A}_{\nu-1}, \overline{M}_{\nu-1})
\end{math}

\paragraph{}

$\{ \overline{C}_0, \overline{C}_1, \ldots \overline{C}_{\nu-1} \}$ are deinterleaved to produce the final ciphertext:

\paragraph{}

\begin{math}
  \hat{C} = \\
  \indent \overline{C}_{0,0} \| \overline{C}_{1,0} \| \overline{C}_{2,0} \| \ldots \| \overline{C}_{(\nu-1),0} \| \\
  \indent \overline{C}_{0,1} \| \overline{C}_{1,1} \| \overline{C}_{2,1} \| \ldots \| \overline{C}_{(\nu-1),1} \| \\
  \indent \overline{C}_{0,2} \| \overline{C}_{1,2} \| \overline{C}_{2,2} \| \ldots \| \overline{C}_{(\nu-1),2} \| \ldots \\
  \\
  C = Trunc(\hat{C}, \lvert P \rvert)
\end{math}

\paragraph{}

Finally, the AEGIS-128X$[\nu]$ authentication tag is the bit-wise exclusive $OR$ of the AEGIS-128L authentication tags:

\paragraph{}

\begin{math}
  T = \overline{T}_0 \oplus \overline{T}_1 \oplus \ldots \oplus \overline{T}_{\nu-1}
\end{math}

\paragraph{}

Note that AEGIS-128L and AEGIS-128X$[1]$ are equivalent.

\subsection{AEGIS-256X}

AEGIS-256X$[\nu]$ uses the exact same interleaving technique as AEGIS-128X$[\nu]$ in order to process $r \cdot \nu$ bits per state update.

The only difference being that fragments are encrypted and authenticated using the AEGIS-256 encryption function instead of the AEGIS-128L one.

\paragraph{}

\begin{math}
  \\
  \{\overline{C}_0, \overline{T}_0\} = Enc_{256}(CTX \leftarrow 0, K, IV, \overline{A}_0, \overline{M}_0) \\
  \{\overline{C}_1, \overline{T}_1\} = Enc_{256}(CTX \leftarrow 1, K, IV, \overline{A}_1, \overline{M}_1) \\
  \{\overline{C}_2, \overline{T}_2\} = Enc_{256}(CTX \leftarrow 2, K, IV, \overline{A}_2, \overline{M}_2) \\
  \vdots \\
  \{\overline{C}_{\nu-1}, \overline{T}_{\nu-1}\} = Enc_{256}(CTX \leftarrow {\nu-1}, K, IV, \overline{A}_{\nu-1}, \overline{M}_{\nu-1})
\end{math}

\paragraph{}

$\{ \overline{C}_0, \overline{C}_1, \ldots \overline{C}_{\nu-1} \}$ are deinterleaved to produce the AEGIS-256X$[\nu]$ ciphertext:

\paragraph{}

\begin{math}
  \hat{C} = \\
  \indent \overline{C}_{0,0} \| \overline{C}_{1,0} \| \overline{C}_{2,0} \| \ldots \| \overline{C}_{(\nu-1),0} \| \\
  \indent \overline{C}_{0,1} \| \overline{C}_{1,1} \| \overline{C}_{2,1} \| \ldots \| \overline{C}_{(\nu-1),1} \| \\
  \indent \overline{C}_{0,2} \| \overline{C}_{1,2} \| \overline{C}_{2,2} \| \ldots \| \overline{C}_{(\nu-1),2} \| \ldots \\
  \\
  C = Trunc(\hat{C}, \lvert P \rvert)
\end{math}

\paragraph{}

Finally, the AEGIS-256X$[\nu]$ authentication tag is the bit-wise exclusive $OR$ of the AEGIS-256 authentication tags:

\paragraph{}

\begin{math}
  T = \overline{T}_0 \oplus \overline{T}_1 \oplus \ldots \oplus \overline{T}_{\nu-1}
\end{math}

\paragraph{}

Note that AEGIS-256 and AEGIS-256X$[1]$ are equivalent.

\section{Rationale}
\label{sec:rationale}

The AEGIS security claims have the following requirements:

\begin{itemize}
  \item Each key should be generated uniformly at random.
  \item Each key and $IV$ pair should not be used to protect more than one message; and each key and $IV$ pair should not be used with two different tag sizes.
  \item If verification fails, the decrypted plaintext and the wrong authentication tag should not be given as output.
\end{itemize}

AEGIS-128X$[\nu]$ and AEGIS-256X$[\nu]$ have the same requirements.

\paragraph{}

$Enc_{128X}[\nu](K, IV, A, M)$ can be seen as $\nu$ evaluations of AEGIS-128L, on $\nu$ independent messages of the same length.

\paragraph{}

In order to satisfy the AEGIS-128L contract, we should either derive distinct keys for each of these messages, or use distinct initialization vectors.

\paragraph{}

The parallelism degree $\nu$, and thus the bounds of $CTX$, are limited by the hardware, and guaranteed to be small.

We could limit the AEGIS-128X$[\nu]$ $IV$ size to $128-log_2(\nu)$ bits (instead of $128$ for AEGIS-128L), encoding the context in the remaining bits to create the $IV$ used by the underlying AEGIS-128L function.
That would be effectively AEGIS-128L, evaluated with independent messages, and distinct $(K, IV)$ pairs.
However, from an application perspective, a $128-log_2(\nu)$ bit initialization vector would be unusual, and at odds with AEGIS-128L.

\paragraph{}

Ideally, we'd like AEGIS-128L to internally support $128+log_2(\nu)$-bit initialization vectors: AEGIS-128X$[\nu]$ applications would use 128 bit initialization vectors, but the context could still be encoded to separate the parallel AEGIS-128L instances.
To put it differently, we need to introduce a context with the same differential properties as the initialization vector.

\paragraph{}

In the proposed tweak to the initialization function, the context is added to the constants in blocks 3 and 7 AEGIS-128L of the initial state.
The purpose of the constants (simply derived from the Fibonacci sequence) is to resist attacks exploiting the symmetry of the AES round function and of the overall AEGIS state.

Given its limited range, adding $\nu$ cannot turn them into weak constants, and doesn't alter any of the AEGIS-128L properties.
Also note that $\nu$ is expected to be a hyperparameter, that an adversary cannot have control of.

\paragraph{}

Differential attacks could be a concern with the same $(K, IV)$ pair used in different contexts.
But in AEGIS-128L, there are 80 AES round functions (10 update steps) in the initialization function. In \cite{STSI23}, Shiraya at al. showed that the initialization phase of AEGIS-128L is secure against differential attacks after 3 update steps.

Furthermore, in order to prevent the difference in the state being eliminated completely in the middle of the initialization, the context difference is repeatedly injected into the state. This is consistent with how 128-bit initialization vectors are absorbed in AEGIS-128L.

The addition of a short context is thus unlikely to invalidate any of the current AEGIS-128L security claims.

\paragraph{}

The above security claims require a key and $IV$ pair not to be used with different tag sizes. The AEGIS-128X$[\nu]$ construction guarantees that internal AEGIS-128L evaluations will always share the same tag size.

\paragraph{}

Note that the addition of a context to the AEGIS-128L initialization function could also be used to create a different initial state for different tag sizes, effectively increasing misuse resistance.

\paragraph{}

The same observations apply to AEGIS-256X$[\nu]$ and its $Enc_{256X}[\nu]$ encryption function.

\paragraph{}

In the AEGIS-256 initialization function, there are 96 round functions (16 update steps). According to the MILP-based evaluation from \cite{STSI23}, AEGIS-256 is secure against differential attacks after 6 update steps.

\paragraph{}

We'd like to emphasize that AEGIS-128X$[\nu]$ and AEGIS-256 are not new algorithms. They are modes, built on top of AEGIS-128L and AEGIS-256. designed to preserve the same security guarantees and requirements.
Keys must be generated uniformly at random, key and $IV$ pairs must not be reused, and for both variants the success rate of a forgery attack remains $2^{-\lvert T \rvert}$.

\paragraph{}

We did not include a parallel variant of AEGIS-128, as opposed to AEGIS-128L. AEGIS-128 trades performance for a smaller state size. But given that performance is the main justification for AEGIS-128X, AEGIS-128L feels like a more natural choice.

\section{Implementation notes}
\label{sec:implementation notes}

Implementing AEGIS-128X$[\nu]$ and AEGIS-256X$[\nu]$ only requires trivial modifications to existing AEGIS-128L and AEGIS-256 implementations.

They apply the exact same operations as AEGIS-128L and AEGIS-256, to vectors of $\nu$ AES blocks instead of single blocks.

For example, with 256-bit registers, two AEGIS-128L states $S$ and $S^{\prime}$ can be stored as:

\begin{math}
  \\
  \{ S_0, S^{\prime}_0 \}, \{ S_1, S^{\prime}_1 \}, \{ S_2, S^{\prime}_2 \}, \ldots \{ S_7, S^{\prime}_7 \}
\end{math}

\paragraph{}

This perfectly matches the AEGIS-128X$[2]$ interleaved representation. In addition to the forward AES permutation, updating an AEGIS state only requires the bit-wise OR and AND operations. Even with wide registers, such operations are very efficient on any CPU with vector instructions.

\paragraph{}

On CPUs that don't implement vectorized versions of the AES permutation, AEGIS-128X$[\nu]$ and AEGIS-256X$[\nu]$ can be implemented in two different ways:

\begin{itemize}
  \item by emulating AES vector instructions. This is the easiest option, keeping the code close to hardware-accelerated versions.
  \item by evaluating $\{ \overline{A}_0, \overline{A}_1, \overline{A}_2, \ldots \overline{A}_{\nu-1} \}$ and $\{ \overline{C}_0, \overline{C}_1, \overline{C}_2, \ldots \overline{C}_{\nu-1} \}$ sequentially, with a periodic synchronization, for example after every memory page. This reduces cache-locality but also register pressure.
\end{itemize}

\section{Performance evaluation}
\label{sec:performance evaluation}

The AEGIS-128X$[\nu]$ and AEGIS-256X$[\nu]$ inputs are transformed into evenly distributed fragments.
As a result, they only yield a performance improvement over their underlying primitives when $\lvert A \rvert > r$ or $\lvert P \rvert > r$.

We implemented AEGIS-128X$[2]$ and AEGIS-256X$[2]$ using the Zig programming language. The code \cite{GitHub:AEGISX} is nearly identical to the reference implementations from the AEGIS specification \cite{DSL2023}, with the \lstinline{AesBlock} type extended to 2 AES blocks.

On Intel, AMD and ARM CPUs with vector registers but without AES vector instructions, AEGIS-128L and AEGIS-256 have better or comparable performance.

And unsurprinsingly, on CPUS without vector registers, AEGIS-128L and AEGIS-256 are consistently faster than their parallel counterparts.

However, on CPUs with the VAES instruction set such as an Intel Raptor Lake processor (table \ref{i9-13900K}) or an AMD EPYC CPU (table \ref{epyc-7543}), AEGIS-128X$[2]$ is almost twice as fast as AEGIS-128L with large inputs.

\begin{table}
  \begin{center}
    \begin{tabular}{|c|c|}
      \hline
      Algorithm       & Throughput  \\
      \hline
      AEGIS-128X$[2]$ & 39781 MiB/s \\
      \hline
      AEGIS-128L      & 23863 MiB/s \\
      \hline
      AES128-GCM      & 10243 MiB/s \\
      \hline
    \end{tabular}
    \caption{\label{i9-13900K}Intel Core i9-13900K benchmark (single core)}
  \end{center}
\end{table}

\begin{table}
  \begin{center}
    \begin{tabular}{|c|c|}
      \hline
      Algorithm       & Throughput  \\
      \hline
      AEGIS-128X$[2]$ & 29070 MiB/s \\
      \hline
      AEGIS-128L      & 15178 MiB/s \\
      \hline
      AES128-GCM      & 4387 MiB/s  \\
      \hline
    \end{tabular}
\caption{\label{epyc-7543}AMD EPYC 7543 benchmark (single core)}
  \end{center}
\end{table}

The benchmarked AES128-GCM implementation is the one from OpenSSL 3.1.0, while the AEGIS implementations are the reference code of the AEGIS specification, as well as our modified version to support for 128X variant.

\ifnum\fullversion=0
  \bibliographystyle{splncs03}
\else
  \bibliographystyle{alpha-short}
\fi
\bibliography{cryptobib/abbrev3,add}

\end{document}